setwd()

library(Hmsc)
library(vioplot)
library(colorspace)

#load Hmsc model generated by script 2.
load("models_thin_1000_samples_250_chains_4.Rdata")

#Extract metrics of explanatory performance per model (Tjur R2 and AUC for occurrence models; 
#R2 for abundance conditional on presence models).

for(j in 4:1)
{
  
  m = models[[j]]
  
  preds = computePredictedValues(m)
  MF = evaluateModelFit(m, predY=preds)
  if(j == 1 | j == 3)
  {
    TjurR2 = MF$TjurR2
    AUC = MF$AUC
    Summary = data.frame(TjurR2, AUC)
    colnames(Summary) = c("TjurR2", "AUC")
    rownames(Summary) = colnames(m$Y)
    write.csv2(Summary, paste0("ExplPerformance_", modelnames[j], ".csv"), row.names = T)
    print(paste0(modelnames[j], ": mean = ", round(mean(Summary[,1], na.rm = T), 2), ", sd = ", round(sd(Summary[,1], na.rm = T), 2), ", range = ", round(min(Summary[,1], na.rm = T), 2), "-", round(max(Summary[,1], na.rm = T), 2)))
  }
  if(j == 2 | j == 4)
  {
    Summary = data.frame(MF$R2)
    colnames(Summary) = "R2"
    rownames(Summary) = colnames(m$Y)
    write.csv2(Summary, paste0("ExplPerformance_", modelnames[j], ".csv"), row.names = T)
    print(paste0(modelnames[j], ": mean = ", round(mean(Summary[,1], na.rm = T), 2), ", sd = ", round(sd(Summary[,1], na.rm = T), 2), ", range = ", round(min(Summary[,1], na.rm = T), 2), "-", round(max(Summary[,1], na.rm = T), 2)))
  }
}

#Examine parameter convergence for beta, omega and alpha parameters (alpha for spatial/temporal random effects)
#Extract estimates per model of the typical scale alpha of any spatial vs temporal autocorrelation.
psrfbeta_summary = data.frame(matrix(0, nrow = 0, ncol = 3))
psrfomega_summary = data.frame(matrix(0, nrow = 0, ncol = 3))
gelman_alpha = list()
alpha_summary = list()
maxOmega = 100

for(j in 1:4)
{
  m = models[[j]]
  
  mpost = convertToCodaObject(m, spNamesNumbers = c(T,F), covNamesNumbers = c(T,F))
  
  psrf.beta = gelman.diag(mpost$Beta,multivariate=FALSE)$psrf
  print(summary(psrf.beta[,1]))
  psrfbeta_summary = rbind(cbind(psrf.beta[,1], modelnames[j], j), psrfbeta_summary)
  
  tmp = mpost$Omega[[1]]
  z = dim(tmp[[1]])[2]
  if(z > maxOmega){
    sel = sample(1:z, size = maxOmega)
    for(i in 1:length(tmp)){
      tmp[[i]] = tmp[[i]][,sel]
    }
  }
  psrf.omega = gelman.diag(tmp, multivariate = FALSE)$psrf
  psrfomega_summary = rbind(cbind(psrf.omega[,1], modelnames[j], j), psrfomega_summary)
  
  
  for(k in 1:2)
  {
    gelman_alpha[[length(gelman_alpha)+1]] = gelman.diag(mpost$Alpha[[k]],multivariate = FALSE)$psrf
    alpha_summary[[length(alpha_summary)+1]] = quantile(unlist(poolMcmcChains(mpost$Alpha[[k]][,1])), c(0.025,0.5,0.975))
  }
}

gelman_alpha
alpha_summary

colnames(psrfbeta_summary) = c("psrf.beta", "model", "modelN")
psrfbeta_summary[,1] = as.numeric(psrfbeta_summary[,1])

#Draw violin plots of potential scale reduction factors of beta parameters per model
pdf("BetaPSRF.pdf", height = 4, width = 6)
vioplot(psrf.beta~modelN,data=psrfbeta_summary,col=rainbow_hcl(4),ylim = c(0.95,1.3), xlab = "model", names = modelnames, cex.names = 0.8)
dev.off()

colnames(psrfomega_summary) = c("psrf.omega", "model", "modelN")
psrfomega_summary[,1] = as.numeric(psrfomega_summary[,1])

#Draw violin plots of potential scale reduction factors of omega parameters per model
pdf("OmegaPSRF.pdf", height = 4, width = 6)
vioplot(psrf.omega~modelN,data=psrfomega_summary,col=rainbow_hcl(4),ylim = c(0.95,1.3), xlab = "model", names = modelnames, cex.names = 0.8)
dev.off()